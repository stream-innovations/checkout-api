// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: tokens.sql

package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const deleteExpiredTokens = `-- name: DeleteExpiredTokens :exec
DELETE FROM tokens WHERE refresh_expires_at < NOW()
`

func (q *Queries) DeleteExpiredTokens(ctx context.Context) error {
	_, err := q.exec(ctx, q.deleteExpiredTokensStmt, deleteExpiredTokens)
	return err
}

const deleteToken = `-- name: DeleteToken :exec
DELETE FROM tokens WHERE token_type = $1 AND credential = $2
`

type DeleteTokenParams struct {
	TokenType  string `json:"token_type"`
	Credential string `json:"credential"`
}

func (q *Queries) DeleteToken(ctx context.Context, arg DeleteTokenParams) error {
	_, err := q.exec(ctx, q.deleteTokenStmt, deleteToken, arg.TokenType, arg.Credential)
	return err
}

const deleteTokensByCredential = `-- name: DeleteTokensByCredential :exec
DELETE FROM tokens WHERE credential = $1
`

func (q *Queries) DeleteTokensByCredential(ctx context.Context, credential string) error {
	_, err := q.exec(ctx, q.deleteTokensByCredentialStmt, deleteTokensByCredential, credential)
	return err
}

const getToken = `-- name: GetToken :one
SELECT token_type, credential, access_token_id, refresh_token_id, access_expires_at, refresh_expires_at, updated_at, created_at FROM tokens
WHERE token_type = $1
AND credential = $2
AND access_token_id = $3
AND refresh_token_id = $4
`

type GetTokenParams struct {
	TokenType      string    `json:"token_type"`
	Credential     string    `json:"credential"`
	AccessTokenID  uuid.UUID `json:"access_token_id"`
	RefreshTokenID uuid.UUID `json:"refresh_token_id"`
}

func (q *Queries) GetToken(ctx context.Context, arg GetTokenParams) (Token, error) {
	row := q.queryRow(ctx, q.getTokenStmt, getToken,
		arg.TokenType,
		arg.Credential,
		arg.AccessTokenID,
		arg.RefreshTokenID,
	)
	var i Token
	err := row.Scan(
		&i.TokenType,
		&i.Credential,
		&i.AccessTokenID,
		&i.RefreshTokenID,
		&i.AccessExpiresAt,
		&i.RefreshExpiresAt,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const storeToken = `-- name: StoreToken :one
INSERT INTO tokens (
	token_type,
	credential,
	access_token_id,
	refresh_token_id,
	access_expires_at,
	refresh_expires_at
) VALUES (
	$1,
	$2,
	$3,
	$4,
	$5,
	$6
) ON CONFLICT (token_type, credential) DO UPDATE SET
	access_token_id = $3,
	refresh_token_id = $4,
	access_expires_at = $5,
	refresh_expires_at = $6
RETURNING token_type, credential, access_token_id, refresh_token_id, access_expires_at, refresh_expires_at, updated_at, created_at
`

type StoreTokenParams struct {
	TokenType        string    `json:"token_type"`
	Credential       string    `json:"credential"`
	AccessTokenID    uuid.UUID `json:"access_token_id"`
	RefreshTokenID   uuid.UUID `json:"refresh_token_id"`
	AccessExpiresAt  time.Time `json:"access_expires_at"`
	RefreshExpiresAt time.Time `json:"refresh_expires_at"`
}

func (q *Queries) StoreToken(ctx context.Context, arg StoreTokenParams) (Token, error) {
	row := q.queryRow(ctx, q.storeTokenStmt, storeToken,
		arg.TokenType,
		arg.Credential,
		arg.AccessTokenID,
		arg.RefreshTokenID,
		arg.AccessExpiresAt,
		arg.RefreshExpiresAt,
	)
	var i Token
	err := row.Scan(
		&i.TokenType,
		&i.Credential,
		&i.AccessTokenID,
		&i.RefreshTokenID,
		&i.AccessExpiresAt,
		&i.RefreshExpiresAt,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}
