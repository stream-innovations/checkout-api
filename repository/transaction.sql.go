// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: transaction.sql

package repository

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions (
    payment_id, 
    reference, 
    source_wallet,
    source_mint,
    destination_wallet,
    destination_mint,
    amount, 
    discount_amount, 
    total_amount,
    accrued_bonus_amount,
    message,
    memo,
    apply_bonus,
    status
) 
VALUES (
    $1, 
    $2, 
    $3,
    $4,
    $5,
    $6,
    $7, 
    $8, 
    $9,
    $10,
    $11,
    $12,
    $13,
    $14
)
RETURNING id, payment_id, reference, source_wallet, source_mint, destination_wallet, destination_mint, amount, discount_amount, total_amount, accrued_bonus_amount, message, memo, apply_bonus, tx_signature, status, created_at, updated_at
`

type CreateTransactionParams struct {
	PaymentID          uuid.UUID         `json:"payment_id"`
	Reference          string            `json:"reference"`
	SourceWallet       string            `json:"source_wallet"`
	SourceMint         string            `json:"source_mint"`
	DestinationWallet  string            `json:"destination_wallet"`
	DestinationMint    string            `json:"destination_mint"`
	Amount             int64             `json:"amount"`
	DiscountAmount     int64             `json:"discount_amount"`
	TotalAmount        int64             `json:"total_amount"`
	AccruedBonusAmount int64             `json:"accrued_bonus_amount"`
	Message            sql.NullString    `json:"message"`
	Memo               sql.NullString    `json:"memo"`
	ApplyBonus         sql.NullBool      `json:"apply_bonus"`
	Status             TransactionStatus `json:"status"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.queryRow(ctx, q.createTransactionStmt, createTransaction,
		arg.PaymentID,
		arg.Reference,
		arg.SourceWallet,
		arg.SourceMint,
		arg.DestinationWallet,
		arg.DestinationMint,
		arg.Amount,
		arg.DiscountAmount,
		arg.TotalAmount,
		arg.AccruedBonusAmount,
		arg.Message,
		arg.Memo,
		arg.ApplyBonus,
		arg.Status,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.PaymentID,
		&i.Reference,
		&i.SourceWallet,
		&i.SourceMint,
		&i.DestinationWallet,
		&i.DestinationMint,
		&i.Amount,
		&i.DiscountAmount,
		&i.TotalAmount,
		&i.AccruedBonusAmount,
		&i.Message,
		&i.Memo,
		&i.ApplyBonus,
		&i.TxSignature,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPendingTransactions = `-- name: GetPendingTransactions :many
SELECT id, payment_id, reference, source_wallet, source_mint, destination_wallet, destination_mint, amount, discount_amount, total_amount, accrued_bonus_amount, message, memo, apply_bonus, tx_signature, status, created_at, updated_at FROM transactions WHERE status = 'pending'::transaction_status
`

func (q *Queries) GetPendingTransactions(ctx context.Context) ([]Transaction, error) {
	rows, err := q.query(ctx, q.getPendingTransactionsStmt, getPendingTransactions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.PaymentID,
			&i.Reference,
			&i.SourceWallet,
			&i.SourceMint,
			&i.DestinationWallet,
			&i.DestinationMint,
			&i.Amount,
			&i.DiscountAmount,
			&i.TotalAmount,
			&i.AccruedBonusAmount,
			&i.Message,
			&i.Memo,
			&i.ApplyBonus,
			&i.TxSignature,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransaction = `-- name: GetTransaction :one
SELECT id, payment_id, reference, source_wallet, source_mint, destination_wallet, destination_mint, amount, discount_amount, total_amount, accrued_bonus_amount, message, memo, apply_bonus, tx_signature, status, created_at, updated_at FROM transactions WHERE id = $1
`

func (q *Queries) GetTransaction(ctx context.Context, id uuid.UUID) (Transaction, error) {
	row := q.queryRow(ctx, q.getTransactionStmt, getTransaction, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.PaymentID,
		&i.Reference,
		&i.SourceWallet,
		&i.SourceMint,
		&i.DestinationWallet,
		&i.DestinationMint,
		&i.Amount,
		&i.DiscountAmount,
		&i.TotalAmount,
		&i.AccruedBonusAmount,
		&i.Message,
		&i.Memo,
		&i.ApplyBonus,
		&i.TxSignature,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransactionByPaymentIDSourceWalletAndMint = `-- name: GetTransactionByPaymentIDSourceWalletAndMint :one
SELECT id, payment_id, reference, source_wallet, source_mint, destination_wallet, destination_mint, amount, discount_amount, total_amount, accrued_bonus_amount, message, memo, apply_bonus, tx_signature, status, created_at, updated_at FROM transactions 
WHERE payment_id = $1 
    AND source_wallet = $2 
    AND source_mint = $3
    AND status = 'pending'::transaction_status
ORDER BY created_at DESC
LIMIT 1
`

type GetTransactionByPaymentIDSourceWalletAndMintParams struct {
	PaymentID    uuid.UUID `json:"payment_id"`
	SourceWallet string    `json:"source_wallet"`
	SourceMint   string    `json:"source_mint"`
}

func (q *Queries) GetTransactionByPaymentIDSourceWalletAndMint(ctx context.Context, arg GetTransactionByPaymentIDSourceWalletAndMintParams) (Transaction, error) {
	row := q.queryRow(ctx, q.getTransactionByPaymentIDSourceWalletAndMintStmt, getTransactionByPaymentIDSourceWalletAndMint, arg.PaymentID, arg.SourceWallet, arg.SourceMint)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.PaymentID,
		&i.Reference,
		&i.SourceWallet,
		&i.SourceMint,
		&i.DestinationWallet,
		&i.DestinationMint,
		&i.Amount,
		&i.DiscountAmount,
		&i.TotalAmount,
		&i.AccruedBonusAmount,
		&i.Message,
		&i.Memo,
		&i.ApplyBonus,
		&i.TxSignature,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransactionByReference = `-- name: GetTransactionByReference :one
SELECT id, payment_id, reference, source_wallet, source_mint, destination_wallet, destination_mint, amount, discount_amount, total_amount, accrued_bonus_amount, message, memo, apply_bonus, tx_signature, status, created_at, updated_at FROM transactions WHERE reference = $1
`

func (q *Queries) GetTransactionByReference(ctx context.Context, reference string) (Transaction, error) {
	row := q.queryRow(ctx, q.getTransactionByReferenceStmt, getTransactionByReference, reference)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.PaymentID,
		&i.Reference,
		&i.SourceWallet,
		&i.SourceMint,
		&i.DestinationWallet,
		&i.DestinationMint,
		&i.Amount,
		&i.DiscountAmount,
		&i.TotalAmount,
		&i.AccruedBonusAmount,
		&i.Message,
		&i.Memo,
		&i.ApplyBonus,
		&i.TxSignature,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransactionsByPaymentID = `-- name: GetTransactionsByPaymentID :many
SELECT id, payment_id, reference, source_wallet, source_mint, destination_wallet, destination_mint, amount, discount_amount, total_amount, accrued_bonus_amount, message, memo, apply_bonus, tx_signature, status, created_at, updated_at FROM transactions WHERE payment_id = $1 ORDER BY created_at DESC
`

func (q *Queries) GetTransactionsByPaymentID(ctx context.Context, paymentID uuid.UUID) ([]Transaction, error) {
	rows, err := q.query(ctx, q.getTransactionsByPaymentIDStmt, getTransactionsByPaymentID, paymentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.PaymentID,
			&i.Reference,
			&i.SourceWallet,
			&i.SourceMint,
			&i.DestinationWallet,
			&i.DestinationMint,
			&i.Amount,
			&i.DiscountAmount,
			&i.TotalAmount,
			&i.AccruedBonusAmount,
			&i.Message,
			&i.Memo,
			&i.ApplyBonus,
			&i.TxSignature,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markTransactionsAsExpired = `-- name: MarkTransactionsAsExpired :exec
UPDATE transactions SET status = 'expired'::transaction_status 
WHERE status = 'pending'::transaction_status AND payment_id IN (
    SELECT id FROM payments WHERE status = 'expired'::payment_status
)
`

func (q *Queries) MarkTransactionsAsExpired(ctx context.Context) error {
	_, err := q.exec(ctx, q.markTransactionsAsExpiredStmt, markTransactionsAsExpired)
	return err
}

const updateTransactionByReference = `-- name: UpdateTransactionByReference :one
UPDATE transactions SET tx_signature = $1, status = $2 WHERE reference = $3 RETURNING id, payment_id, reference, source_wallet, source_mint, destination_wallet, destination_mint, amount, discount_amount, total_amount, accrued_bonus_amount, message, memo, apply_bonus, tx_signature, status, created_at, updated_at
`

type UpdateTransactionByReferenceParams struct {
	TxSignature sql.NullString    `json:"tx_signature"`
	Status      TransactionStatus `json:"status"`
	Reference   string            `json:"reference"`
}

func (q *Queries) UpdateTransactionByReference(ctx context.Context, arg UpdateTransactionByReferenceParams) (Transaction, error) {
	row := q.queryRow(ctx, q.updateTransactionByReferenceStmt, updateTransactionByReference, arg.TxSignature, arg.Status, arg.Reference)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.PaymentID,
		&i.Reference,
		&i.SourceWallet,
		&i.SourceMint,
		&i.DestinationWallet,
		&i.DestinationMint,
		&i.Amount,
		&i.DiscountAmount,
		&i.TotalAmount,
		&i.AccruedBonusAmount,
		&i.Message,
		&i.Memo,
		&i.ApplyBonus,
		&i.TxSignature,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
